import{L as m,b as p,e as c,ah as y,u as b,r as w}from"./index-CfS70t6F.js";import{A as d,G as g}from"./glTFLoader-DQB8554u.js";import"./objectModelMapping-D4YYZYlG.js";class A{constructor(n,e,o){this.frame=n,this.action=e,this.onlyOnce=o,this.isDone=!1}_clone(){return new A(this.frame,this.action,this.onlyOnce)}}class E{constructor(n,e,o){if(this.loop=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._volume=1,this.isPlaying=!1,this.isPaused=!1,this._sounds=[],this._weights=[],e.length!==o.length)throw new Error("Sounds length does not equal weights length");this.loop=n,this._weights=o;let s=0;for(const r of o)s+=r;const i=s>0?1/s:0;for(let r=0;r<this._weights.length;r++)this._weights[r]*=i;this._sounds=e;for(const r of this._sounds)r.onEndedObservable.add(()=>{this._onended()})}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(n){if(n!==this._coneInnerAngle){if(this._coneOuterAngle<n){m.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=n;for(const e of this._sounds)e.directionalConeInnerAngle=n}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(n){if(n!==this._coneOuterAngle){if(n<this._coneInnerAngle){m.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=n;for(const e of this._sounds)e.directionalConeOuterAngle=n}}get volume(){return this._volume}set volume(n){if(n!==this._volume)for(const e of this._sounds)e.setVolume(n)}_onended(){this._currentIndex!==void 0&&(this._sounds[this._currentIndex].autoplay=!1),this.loop&&this.isPlaying?this.play():this.isPlaying=!1}pause(){this.isPlaying&&(this.isPaused=!0,this._currentIndex!==void 0&&this._sounds[this._currentIndex].pause())}stop(){this.isPlaying=!1,this._currentIndex!==void 0&&this._sounds[this._currentIndex].stop()}play(n){if(!this.isPaused){this.stop();const o=Math.random();let s=0;for(let i=0;i<this._weights.length;i++)if(s+=this._weights[i],o<=s){this._currentIndex=i;break}}const e=this._sounds[this._currentIndex??0];e.isReady()?e.play(0,this.isPaused?void 0:n):e.autoplay=!0,this.isPlaying=!0,this.isPaused=!1}}const f="MSFT_audio_emitter";class I{constructor(n){this.name=f,this._loader=n,this.enabled=this._loader.isExtensionUsed(f)}dispose(){this._loader=null,this._clips=null,this._emitters=null}onLoading(){const n=this._loader.gltf.extensions;if(n&&n[this.name]){const e=n[this.name];this._clips=e.clips,this._emitters=e.emitters,d.Assign(this._clips),d.Assign(this._emitters)}}loadSceneAsync(n,e){return g.LoadExtensionAsync(n,e,this.name,(o,s)=>{const i=new Array;i.push(this._loader.loadSceneAsync(n,e));for(const r of s.emitters){const t=d.Get(`${o}/emitters`,this._emitters,r);if(t.refDistance!=null||t.maxDistance!=null||t.rolloffFactor!=null||t.distanceModel!=null||t.innerAngle!=null||t.outerAngle!=null)throw new Error(`${o}: Direction or Distance properties are not allowed on emitters attached to a scene`);i.push(this._loadEmitterAsync(`${o}/emitters/${t.index}`,t))}return Promise.all(i).then(()=>{})})}loadNodeAsync(n,e,o){return g.LoadExtensionAsync(n,e,this.name,(s,i)=>{const r=new Array;return this._loader.loadNodeAsync(s,e,t=>{for(const l of i.emitters){const a=d.Get(`${s}/emitters`,this._emitters,l);r.push(this._loadEmitterAsync(`${s}/emitters/${a.index}`,a).then(()=>{for(const u of a._babylonSounds)u.attachToMesh(t),(a.innerAngle!=null||a.outerAngle!=null)&&(u.setLocalDirectionToMesh(p.Forward()),u.setDirectionalCone(2*c.ToDegrees(a.innerAngle==null?Math.PI:a.innerAngle),2*c.ToDegrees(a.outerAngle==null?Math.PI:a.outerAngle),0))}))}o(t)}).then(t=>Promise.all(r).then(()=>t))})}loadAnimationAsync(n,e){return g.LoadExtensionAsync(n,e,this.name,(o,s)=>this._loader.loadAnimationAsync(n,e).then(i=>{const r=new Array;d.Assign(s.events);for(const t of s.events)r.push(this._loadAnimationEventAsync(`${o}/events/${t.index}`,n,e,t,i));return Promise.all(r).then(()=>i)}))}_loadClipAsync(n,e){if(e._objectURL)return e._objectURL;let o;if(e.uri)o=this._loader.loadUriAsync(n,e,e.uri);else{const s=d.Get(`${n}/bufferView`,this._loader.gltf.bufferViews,e.bufferView);o=this._loader.loadBufferViewAsync(`/bufferViews/${s.index}`,s)}return e._objectURL=o.then(s=>URL.createObjectURL(new Blob([s],{type:e.mimeType}))),e._objectURL}_loadEmitterAsync(n,e){if(e._babylonSounds=e._babylonSounds||[],!e._babylonData){const o=new Array,s=e.name||`emitter${e.index}`,i={loop:!1,autoplay:!1,volume:e.volume==null?1:e.volume};for(let t=0;t<e.clips.length;t++){const l=`/extensions/${this.name}/clips`,a=d.Get(l,this._clips,e.clips[t].clip);o.push(this._loadClipAsync(`${l}/${e.clips[t].clip}`,a).then(u=>{const h=e._babylonSounds[t]=new y(s,u,this._loader.babylonScene,null,i);h.refDistance=e.refDistance||1,h.maxDistance=e.maxDistance||256,h.rolloffFactor=e.rolloffFactor||1,h.distanceModel=e.distanceModel||"exponential"}))}const r=Promise.all(o).then(()=>{const t=e.clips.map(a=>a.weight||1),l=new E(e.loop||!1,e._babylonSounds,t);e.innerAngle&&(l.directionalConeInnerAngle=2*c.ToDegrees(e.innerAngle)),e.outerAngle&&(l.directionalConeOuterAngle=2*c.ToDegrees(e.outerAngle)),e.volume&&(l.volume=e.volume),e._babylonData.sound=l});e._babylonData={loaded:r}}return e._babylonData.loaded}_getEventAction(n,e,o,s,i){switch(o){case"play":return r=>{const t=(i||0)+(r-s);e.play(t)};case"stop":return()=>{e.stop()};case"pause":return()=>{e.pause()};default:throw new Error(`${n}: Unsupported action ${o}`)}}_loadAnimationEventAsync(n,e,o,s,i){if(i.targetedAnimations.length==0)return Promise.resolve();const r=i.targetedAnimations[0],t=s.emitter,l=d.Get(`/extensions/${this.name}/emitters`,this._emitters,t);return this._loadEmitterAsync(n,l).then(()=>{const a=l._babylonData.sound;if(a){const u=new A(s.time,this._getEventAction(n,a,s.action,s.time,s.startOffset));r.animation.addEvent(u),i.onAnimationGroupEndObservable.add(()=>{a.stop()}),i.onAnimationGroupPauseObservable.add(()=>{a.pause()})}})}}b(f);w(f,!0,_=>new I(_));export{I as MSFT_audio_emitter};
