import{av as U,aw as P,ax as _,L as D,ay as C,az as I,aA as M,aB as T,aC as F,aD as N,aE as W,aF as g,aG as k,aH as B,aI as Z,aJ as m,e as z,aK as O,aL as S,aM as G,aN as H,aO as L,aP as X,aQ as Y,aR as j}from"./index-CfS70t6F.js";const V=20000630;function J(n,l){if(n.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const a=n.getUint8(4),i=n.getUint8(5),t={singleTile:!!(i&2),longName:!!(i&4),deepFormat:!!(i&8),multiPart:!!(i&16)};l.value=8;const r={};let e=!0;for(;e;){const s=U(n.buffer,l);if(!s)e=!1;else{const c=U(n.buffer,l),o=P(n,l),u=_(n,l,c,o);u===void 0?D.Warn(`Unknown header attribute type ${c}'.`):r[s]=u}}if((i&-5)!=0)throw new Error("Unsupported file format");return{version:a,spec:t,...r}}function K(n){let l=n.byteLength;const a=new Array;let i=0;const t=new DataView(n);for(;l>0;){const r=t.getInt8(i++);if(r<0){const e=-r;l-=e+1;for(let s=0;s<e;s++)a.push(t.getUint8(i++))}else{const e=r;l-=2;const s=t.getUint8(i++);for(let c=0;c<e+1;c++)a.push(s)}}return a}function v(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function Q(n){const l=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),a=new Uint8Array(K(l)),i=new Uint8Array(a.length);return k(a),B(a,i),new DataView(i.buffer)}function x(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),a=fflate.unzlibSync(l),i=new Uint8Array(a.length);return k(a),B(a,i),new DataView(i.buffer)}function $(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),a=fflate.unzlibSync(l),i=n.lines*n.channels*n.width,t=n.type==1?new Uint16Array(i):new Uint32Array(i);let r=0,e=0;const s=new Array(4);for(let c=0;c<n.lines;c++)for(let o=0;o<n.channels;o++){let u=0;switch(n.type){case 1:s[0]=r,s[1]=s[0]+n.width,r=s[1]+n.width;for(let h=0;h<n.width;++h){const w=a[s[0]++]<<8|a[s[1]++];u+=w,t[e]=u,e++}break;case 2:s[0]=r,s[1]=s[0]+n.width,s[2]=s[1]+n.width,r=s[2]+n.width;for(let h=0;h<n.width;++h){const w=a[s[0]++]<<24|a[s[1]++]<<16|a[s[2]++]<<8;u+=w,t[e]=u,e++}break}}return new DataView(t.buffer)}function q(n){const l=n.viewer,a={value:n.offset.value},i=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),t=new Uint8Array(I);let r=0;const e=new Array(n.channels);for(let f=0;f<n.channels;f++)e[f]={},e[f].start=r,e[f].end=e[f].start,e[f].nx=n.width,e[f].ny=n.lines,e[f].size=n.type,r+=e[f].nx*e[f].ny*e[f].size;const s=C(l,a),c=C(l,a);if(c>=I)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(s<=c)for(let f=0;f<c-s+1;f++)t[f+s]=M(l,a);const o=new Uint16Array(Z),u=T(t,o),h=P(l,a);F(n.array,l,a,h,i,r);for(let f=0;f<n.channels;++f){const p=e[f];for(let y=0;y<e[f].size;++y)N(i,p.start+y,p.nx,p.size,p.ny,p.nx*p.size,u)}W(o,i,r);let w=0;const E=new Uint8Array(i.buffer.byteLength);for(let f=0;f<n.lines;f++)for(let p=0;p<n.channels;p++){const y=e[p],b=y.nx*y.size,A=new Uint8Array(i.buffer,y.end*g,b*g);E.set(A,w),w+=b*g,y.end+=b}return new DataView(E.buffer)}async function d(n,l,a,i){const t={size:0,viewer:l,array:new Uint8Array(l.buffer),offset:a,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case m.NO_COMPRESSION:t.lines=1,t.uncompress=v;break;case m.RLE_COMPRESSION:t.lines=1,t.uncompress=Q;break;case m.ZIPS_COMPRESSION:t.lines=1,t.uncompress=x,await z.LoadScriptAsync(O.FFLATEUrl);break;case m.ZIP_COMPRESSION:t.lines=16,t.uncompress=x,await z.LoadScriptAsync(O.FFLATEUrl);break;case m.PIZ_COMPRESSION:t.lines=32,t.uncompress=q;break;case m.PXR24_COMPRESSION:t.lines=16,t.uncompress=$,await z.LoadScriptAsync(O.FFLATEUrl);break;default:throw new Error(m[n.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const r={};for(const o of n.channels)switch(o.name){case"Y":case"R":case"G":case"B":case"A":r[o.name]=!0,t.type=o.pixelType}let e=!1;if(r.R&&r.G&&r.B)e=!r.A,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(r.Y)t.outputChannels=1,t.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(t.type===1)switch(i){case S.Float:t.getter=G,t.inputSize=g;break;case S.HalfFloat:t.getter=C,t.inputSize=g;break}else if(t.type===2)switch(i){case S.Float:t.getter=X,t.inputSize=L;break;case S.HalfFloat:t.getter=H,t.inputSize=L}else throw new Error("Unsupported pixelType "+t.type+" for "+n.compression);t.blockCount=t.height/t.scanlineBlockSize;for(let o=0;o<t.blockCount;o++)Y(l,a);const s=t.width*t.height*t.outputChannels;switch(i){case S.Float:t.byteArray=new Float32Array(s),t.textureType=1,e&&t.byteArray.fill(1,0,s);break;case S.HalfFloat:t.byteArray=new Uint16Array(s),t.textureType=2,e&&t.byteArray.fill(15360,0,s);break;default:throw new Error("Unsupported type: "+i)}let c=0;for(const o of n.channels)t.decodeChannels[o.name]!==void 0&&(t.channelLineOffsets[o.name]=c*t.width),c+=o.pixelType*2;return t.bytesPerLine=t.width*c,t.outLineWidth=t.width*t.outputChannels,n.lineOrder==="INCREASING_Y"?t.scanOrder=o=>o:t.scanOrder=o=>t.height-1-o,t.outputChannels==4?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}function nn(n,l,a,i){const t={value:0};for(let r=0;r<n.height/n.scanlineBlockSize;r++){const e=j(a,i)-l.dataWindow.yMin;n.size=P(a,i),n.lines=e+n.scanlineBlockSize>n.height?n.height-e:n.scanlineBlockSize;const c=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):v(n);i.value+=n.size;for(let o=0;o<n.scanlineBlockSize;o++){const u=r*n.scanlineBlockSize,h=o+n.scanOrder(u);if(h>=n.height)continue;const w=o*n.bytesPerLine,E=(n.height-1-h)*n.outLineWidth;for(let f=0;f<n.channels;f++){const p=l.channels[f].name,y=n.channelLineOffsets[p],b=n.decodeChannels[p];if(b!==void 0){t.value=w+y;for(let A=0;A<n.width;A++){const R=E+A*n.outputChannels+b;n.byteArray&&(n.byteArray[R]=n.getter(c,t))}}}}}}class en{constructor(){this.supportCascades=!1}loadCubeData(l,a,i,t,r){throw".exr not supported in Cube."}async loadData(l,a,i){const t=new DataView(l.buffer),r={value:0},e=J(t,r),s=await d(e,t,r,O.DefaultOutputType);nn(s,e,t,r);const c=e.dataWindow.xMax-e.dataWindow.xMin+1,o=e.dataWindow.yMax-e.dataWindow.yMin+1;i(c,o,a.generateMipMaps,!1,()=>{const u=a.getEngine();a.format=e.format,a.type=s.textureType,a.invertY=!1,a._gammaSpace=!e.linearSpace,s.byteArray&&u._uploadDataToTextureDirectly(a,s.byteArray,0,0,void 0,!0)})}}export{en as _ExrTextureLoader};
