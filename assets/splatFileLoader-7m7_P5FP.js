import{f as R,M as q,d as L,g as N,h as z,P as F,A as H,L as Z,b as $,a as J,R as K}from"./index-CfS70t6F.js";var D;(function(S){S[S.Splat=0]="Splat",S[S.PointCloud=1]="PointCloud",S[S.Mesh=2]="Mesh",S[S.Reject=3]="Reject"})(D||(D={}));class P{constructor(a=P._DefaultLoadingOptions){this.name=R.name,this._assetContainer=null,this.extensions=R.extensions,this._loadingOptions=a}createPlugin(a){return new P(a[R.name])}async importMeshAsync(a,r,t,c,n,f){return this._parse(a,r,t,c).then(w=>({meshes:w,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]}))}static _BuildPointCloud(a,r){if(!r.byteLength)return!1;const t=new Uint8Array(r),c=new Float32Array(r),n=3*4+3*4+4+4,f=t.length/n,w=function(x,l){const s=c[8*l+0],o=c[8*l+1],p=c[8*l+2];x.position=new $(s,o,p);const y=t[n*l+24+0]/255,g=t[n*l+24+1]/255,i=t[n*l+24+2]/255;x.color=new J(y,g,i,1)};return a.addPoints(f,w),!0}static _BuildMesh(a,r){const t=new q("PLYMesh",a),c=new Uint8Array(r.data),n=new Float32Array(r.data),f=3*4+3*4+4+4,w=c.length/f,x=[],l=new L;for(let s=0;s<w;s++){const o=n[8*s+0],p=n[8*s+1],y=n[8*s+2];x.push(o,p,y)}if(r.hasVertexColors){const s=new Float32Array(w*4);for(let o=0;o<w;o++){const p=c[f*o+24+0]/255,y=c[f*o+24+1]/255,g=c[f*o+24+2]/255;s[o*4+0]=p,s[o*4+1]=y,s[o*4+2]=g,s[o*4+3]=1}l.colors=s}return l.positions=x,l.indices=r.faces,l.applyToMesh(t),t}_parseSPZ(a,r){const t=new Uint8Array(a),c=new Uint32Array(a),n=c[2],f=t[12],w=t[13];if(t[15]||c[0]!=1347635022||c[1]!=2)return new Promise(e=>{e({mode:3,data:s,hasVertexColors:!1})});const l=3*4+3*4+4+4,s=new ArrayBuffer(l*n),o=1/(1<<w),p=new Int32Array(1),y=new Uint8Array(p.buffer),g=function(e,h){return y[0]=e[h+0],y[1]=e[h+1],y[2]=e[h+2],y[3]=e[h+2]&128?255:0,p[0]*o};let i=16;const M=new Float32Array(s),U=new Float32Array(s),B=new Uint8ClampedArray(s),v=new Uint8ClampedArray(s);let u=1,d=0;this._loadingOptions.flipY||(u=-1,d=255);for(let e=0;e<n;e++)M[e*8+0]=g(t,i+0),M[e*8+1]=u*g(t,i+3),M[e*8+2]=u*g(t,i+6),i+=9;const V=.282;for(let e=0;e<n;e++){for(let h=0;h<3;h++){const A=(t[i+n+e*3+h]-127.5)/(.15*255);B[e*32+24+h]=N.Clamp((.5+V*A)*255,0,255)}B[e*32+24+3]=t[i+e]}i+=n*4;for(let e=0;e<n;e++)U[e*8+3+0]=Math.exp(t[i+0]/16-10),U[e*8+3+1]=Math.exp(t[i+1]/16-10),U[e*8+3+2]=Math.exp(t[i+2]/16-10),i+=3;for(let e=0;e<n;e++){const h=t[i+0],b=t[i+1]*u+d,A=t[i+2]*u+d,k=h/127.5-1,O=b/127.5-1,I=A/127.5-1;v[e*32+28+1]=h,v[e*32+28+2]=b,v[e*32+28+3]=A;const m=1-(k*k+O*O+I*I);v[e*32+28+0]=127.5+Math.sqrt(m<0?0:m)*127.5,i+=3}if(f){const h=((f+1)*(f+1)-1)*3,b=Math.ceil(h/16);let A=i;const k=[],I=r.getEngine().getCaps().maxTextureSize,m=Math.ceil(n/I);for(let C=0;C<b;C++){const _=new Uint8Array(m*I*4*4);k.push(_)}for(let C=0;C<n;C++)for(let _=0;_<h;_++){const E=t[A++],T=Math.floor(_/16),W=k[T],G=_%16,j=C*16;W[G+j]=E}return new Promise(C=>{C({mode:0,data:s,hasVertexColors:!1,sh:k})})}return new Promise(e=>{e({mode:0,data:s,hasVertexColors:!1})})}_parse(a,r,t,c){const n=[],f=new ReadableStream({start(l){l.enqueue(new Uint8Array(t)),l.close()}}),w=new DecompressionStream("gzip"),x=f.pipeThrough(w);return new Promise(l=>{new Response(x).arrayBuffer().then(s=>{this._parseSPZ(s,r).then(o=>{r._blockEntityCollection=!!this._assetContainer;const p=new z("GaussianSplatting",null,r,this._loadingOptions.keepInRam);p._parentContainer=this._assetContainer,n.push(p),p.updateData(o.data,o.sh),r._blockEntityCollection=!1,l(n)})}).catch(()=>{P._ConvertPLYToSplat(t).then(async s=>{switch(r._blockEntityCollection=!!this._assetContainer,s.mode){case 0:{const o=new z("GaussianSplatting",null,r,this._loadingOptions.keepInRam);o._parentContainer=this._assetContainer,n.push(o),o.updateData(s.data)}break;case 1:{const o=new F("PointCloud",1,r);P._BuildPointCloud(o,s.data)?await o.buildMeshAsync().then(p=>{n.push(p)}):o.dispose()}break;case 2:if(s.faces)n.push(P._BuildMesh(r,s));else throw new Error("PLY mesh doesn't contain face informations.");break;default:throw new Error("Unsupported Splat mode")}r._blockEntityCollection=!1,l(n)})})})}loadAssetContainerAsync(a,r,t){const c=new H(a);return this._assetContainer=c,this.importMeshAsync(null,a,r,t).then(n=>(n.meshes.forEach(f=>c.meshes.push(f)),this._assetContainer=null,c)).catch(n=>{throw this._assetContainer=null,n})}loadAsync(a,r,t){return this.importMeshAsync(null,a,r,t).then(()=>{})}static _ConvertPLYToSplat(a){const r=new Uint8Array(a),t=new TextDecoder().decode(r.slice(0,1024*10)),c=`end_header
`,n=t.indexOf(c);if(n<0||!t)return new Promise(u=>{u({mode:0,data:a})});const f=parseInt(/element vertex (\d+)\n/.exec(t)[1]),w=/element face (\d+)\n/.exec(t);let x=0;w&&(x=parseInt(w[1]));const l=/element chunk (\d+)\n/.exec(t);let s=0;l&&(s=parseInt(l[1]));let o=0,p=0;const y={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let g;(function(u){u[u.Vertex=0]="Vertex",u[u.Chunk=1]="Chunk"})(g||(g={}));let i=1;const M=[],U=t.slice(0,n).split(`
`);for(const u of U)if(u.startsWith("property ")){const[,d,V]=u.split(" ");i==1?p+=y[d]:i==0&&(M.push({name:V,type:d,offset:o}),o+=y[d]),y[d]||Z.Warn(`Unsupported property type: ${d}.`)}else if(u.startsWith("element ")){const[,d]=u.split(" ");d=="chunk"?i=1:d=="vertex"&&(i=0)}const B=o,v=p;return z.ConvertPLYWithSHToSplatAsync(a).then(u=>{const d=new DataView(a,n+c.length);let V=v*s+B*f;const e=[];if(x)for(let m=0;m<x;m++){const C=d.getUint8(V);if(C==3){V+=1;for(let _=0;_<C;_++){const E=d.getUint32(V+(2-_)*4,!0);e.push(E)}V+=12}}if(s)return new Promise(m=>{m({mode:0,data:u.buffer,sh:u.sh,faces:e,hasVertexColors:!1})});let h=0,b=0;const A=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],k=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let m=0;m<M.length;m++){const C=M[m];A.includes(C.name)&&h++,k.includes(C.name)&&b++}const O=h==A.length&&b==3,I=x?2:O?0:1;return new Promise(m=>{m({mode:I,data:u.buffer,sh:u.sh,faces:e,hasVertexColors:!!b})})})}}P._DefaultLoadingOptions={keepInRam:!1,flipY:!1};K(new P);export{P as SPLATFileLoader};
